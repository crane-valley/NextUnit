[{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870638","pull_request_review_id":3701055946,"id":2723870638,"node_id":"PRRC_kwDOQhEeKs6iWveu","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The fully qualified type names `System.Collections.Generic.Dictionary` and `System.Collections.Generic.HashSet` make the code verbose. Consider adding a using directive for `System.Collections.Generic` at the top of the file and using the short names `Dictionary` and `HashSet` instead.","created_at":"2026-01-24T08:23:05Z","updated_at":"2026-01-24T08:23:06Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870638","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870638"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870638"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870638/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":32,"start_side":"RIGHT","line":null,"original_line":41,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":41,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870641","pull_request_review_id":3701055946,"id":2723870641,"node_id":"PRRC_kwDOQhEeKs6iWvex","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The fully qualified type names `System.Collections.Generic.Dictionary` and `System.Collections.Generic.HashSet` make the code verbose. Consider adding a using directive for `System.Collections.Generic` at the top of the file and using the short names `Dictionary` and `HashSet` instead.","created_at":"2026-01-24T08:23:05Z","updated_at":"2026-01-24T08:23:06Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870641","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870641"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870641"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870641/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":46,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870642","pull_request_review_id":3701055946,"id":2723870642,"node_id":"PRRC_kwDOQhEeKs6iWvey","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The fully qualified type name `System.Collections.Generic.HashSet` makes the code verbose. Consider adding a using directive for `System.Collections.Generic` at the top of the file and using the short name `HashSet` instead.","created_at":"2026-01-24T08:23:05Z","updated_at":"2026-01-24T08:23:06Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870642","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870642"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870642"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870642/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":49,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":49,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870644","pull_request_review_id":3701055946,"id":2723870644,"node_id":"PRRC_kwDOQhEeKs6iWve0","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }\n+    }\n+\n+    private static bool HasCycle(\n+        string testId,\n+        System.Collections.Generic.HashSet<string> visited,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> graph)","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The fully qualified type names `System.Collections.Generic.Dictionary` and `System.Collections.Generic.HashSet` make the code verbose. Consider adding a using directive for `System.Collections.Generic` at the top of the file and using the short names `Dictionary` and `HashSet` instead.","created_at":"2026-01-24T08:23:06Z","updated_at":"2026-01-24T08:23:06Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870644","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870644"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723870644"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723870644/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":291,"start_side":"RIGHT","line":null,"original_line":292,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":292,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871962","pull_request_review_id":3701058564,"id":2723871962,"node_id":"PRRC_kwDOQhEeKs6iWvza","diff_hunk":"@@ -0,0 +1,168 @@\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Diagnostics;\n+using System.Reflection;\n+\n+namespace NextUnit.Internal;\n+\n+/// <summary>\n+/// Provides unified display name building functionality for test cases.\n+/// Consolidates duplicate logic from ClassDataSourceExpander, CombinedDataSourceExpander, and TestDataExpander.\n+/// </summary>\n+internal static class DisplayNameBuilder\n+{\n+    private static readonly ConcurrentDictionary<Type, IDisplayNameFormatter> FormatterCache = new();\n+\n+    /// <summary>\n+    /// Builds a display name for a test case using the priority order:\n+    /// 1. Custom formatter (if formatterType is specified)\n+    /// 2. Custom template with placeholders (if customDisplayNameTemplate is specified)\n+    /// 3. Default formatting (MethodName(arg1, arg2, ...))\n+    /// </summary>\n+    /// <param name=\"methodName\">The test method name.</param>\n+    /// <param name=\"customDisplayNameTemplate\">Optional custom display name template with placeholders.</param>\n+    /// <param name=\"formatterType\">Optional custom formatter type implementing IDisplayNameFormatter.</param>\n+    /// <param name=\"testClass\">The test class type.</param>\n+    /// <param name=\"arguments\">The test arguments.</param>\n+    /// <param name=\"argumentSetIndex\">The index of the argument set (for default naming).</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string Build(\n+        string methodName,\n+        string? customDisplayNameTemplate,\n+        Type? formatterType,\n+        Type testClass,\n+        object?[] arguments,\n+        int argumentSetIndex)\n+    {\n+        // Priority 1: Custom formatter\n+        if (formatterType is not null)\n+        {\n+            try\n+            {\n+                var formatter = GetFormatter(formatterType);\n+                var context = new DisplayNameContext\n+                {\n+                    MethodName = methodName,\n+                    TestClass = testClass,\n+                    Arguments = arguments,\n+                    ArgumentSetIndex = argumentSetIndex\n+                };\n+                return formatter.Format(context);\n+            }\n+            catch (InvalidOperationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.Message}\");\n+                // Fall through to next priority\n+            }\n+            catch (TargetInvocationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.InnerException?.Message ?? ex.Message}\");\n+                // Fall through to next priority\n+            }\n+        }\n+\n+        // Priority 2: Custom template with placeholders\n+        if (customDisplayNameTemplate is not null)\n+        {\n+            return FormatWithPlaceholders(customDisplayNameTemplate, arguments);\n+        }\n+\n+        // Priority 3: Default formatting\n+        if (arguments.Length == 0)\n+        {\n+            return methodName;\n+        }\n+\n+        var formattedArgs = string.Join(\", \", arguments.Select(FormatArgument));\n+        return $\"{methodName}({formattedArgs})\";\n+    }\n+\n+    /// <summary>\n+    /// Formats a display name template by replacing placeholders with argument values.\n+    /// Supports {0}, {1}, etc. for positional arguments.\n+    /// </summary>\n+    /// <param name=\"template\">The template string with placeholders.</param>\n+    /// <param name=\"arguments\">The arguments to substitute.</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string FormatWithPlaceholders(string template, object?[] arguments)\n+    {\n+        var result = template;\n+\n+        for (var i = 0; i < arguments.Length; i++)\n+        {\n+            var placeholder = $\"{{{i}}}\";\n+            if (result.Contains(placeholder))\n+            {\n+                result = result.Replace(placeholder, FormatArgument(arguments[i]));\n+            }\n+        }\n+\n+        return result;","path":"src/NextUnit.Core/Internal/DisplayNameBuilder.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nUsing `string.Replace` in a loop can be inefficient as it creates a new string for each replacement. For better performance, especially with templates that might have multiple placeholders, it's recommended to use `System.Text.StringBuilder`. Its `Replace` method modifies the builder in-place, avoiding intermediate string allocations.\n\n```c#\n        var sb = new System.Text.StringBuilder(template);\n\n        for (var i = 0; i < arguments.Length; i++)\n        {\n            var placeholder = ${\"{{{i}}}\"};\n            sb.Replace(placeholder, FormatArgument(arguments[i]));\n        }\n\n        return sb.ToString();\n```","created_at":"2026-01-24T08:25:12Z","updated_at":"2026-01-24T08:25:12Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871962","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871962"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871962"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871962/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":89,"start_side":"RIGHT","line":null,"original_line":100,"side":"RIGHT","author_association":"NONE","original_position":100,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871964","pull_request_review_id":3701058564,"id":2723871964,"node_id":"PRRC_kwDOQhEeKs6iWvzc","diff_hunk":"@@ -51,4 +53,65 @@ public static void Dispose(object? instance)\n             asyncDisposable.DisposeAsync().AsTask().ConfigureAwait(false).GetAwaiter().GetResult();\n         }\n     }\n+\n+    /// <summary>\n+    /// Disposes all objects in a collection.\n+    /// </summary>\n+    /// <param name=\"instances\">The collection of objects to dispose.</param>\n+    public static void DisposeAllIn(IEnumerable<object> instances)\n+    {\n+        foreach (var instance in instances)\n+        {\n+            DisposeIfNeeded(instance);\n+        }\n+    }\n+\n+    /// <summary>\n+    /// Disposes an object with error handling for cleanup scenarios.\n+    /// Logs errors but does not throw (except for fatal exceptions).\n+    /// </summary>\n+    /// <param name=\"instance\">The object to dispose.</param>\n+    /// <remarks>\n+    /// <para>\n+    /// <b>Warning:</b> This method blocks on async disposal using GetAwaiter().GetResult().\n+    /// In synchronization contexts that don't allow blocking (e.g., UI threads),\n+    /// this could potentially cause deadlocks. In test frameworks, this is typically safe\n+    /// as tests run on thread pool threads without special synchronization contexts.\n+    /// </para>\n+    /// <para>\n+    /// If deadlocks occur in production use, consider implementing a fully async cleanup path.\n+    /// </para>\n+    /// </remarks>\n+    public static void DisposeIfNeeded(object? instance)\n+    {\n+        if (instance is null)\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            if (instance is IAsyncDisposable asyncDisposable)\n+            {\n+                asyncDisposable.DisposeAsync().AsTask().GetAwaiter().GetResult();\n+            }\n+            else if (instance is IDisposable disposable)\n+            {\n+                disposable.Dispose();\n+            }","path":"src/NextUnit.Core/Internal/DisposeHelper.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nThere's a small inconsistency in the disposal logic within this class. The existing `DisposeAsync` and `Dispose` methods prefer `IDisposable` over `IAsyncDisposable` (with a comment about backward compatibility). However, this new `DisposeIfNeeded` method prefers `IAsyncDisposable`. For consistency within the `DisposeHelper` class, it would be better to align the check order.\n\n```c#\n            if (instance is IDisposable disposable)\n            {\n                disposable.Dispose();\n            }\n            else if (instance is IAsyncDisposable asyncDisposable)\n            {\n                asyncDisposable.DisposeAsync().AsTask().GetAwaiter().GetResult();\n            }\n```","created_at":"2026-01-24T08:25:12Z","updated_at":"2026-01-24T08:25:12Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871964","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871964"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871964"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871964/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":94,"start_side":"RIGHT","line":null,"original_line":101,"side":"RIGHT","author_association":"NONE","original_position":55,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871966","pull_request_review_id":3701058564,"id":2723871966,"node_id":"PRRC_kwDOQhEeKs6iWvze","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"gemini-code-assist[bot]","id":176961590,"node_id":"BOT_kgDOCow4Ng","avatar_url":"https://avatars.githubusercontent.com/in/956858?v=4","gravatar_id":"","url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D","html_url":"https://github.com/apps/gemini-code-assist","followers_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/followers","following_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/repos","events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/gemini-code-assist%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)\n\nUsing fully qualified names for generic collections like `Dictionary` and `HashSet` makes the code verbose. To improve readability, you can add `using System.Collections.Generic;` at the top of the file. This will allow you to use the shorter type names throughout this new validator class, making method signatures and implementations cleaner. This suggestion should be applied consistently across the file.\n\n```c#\n    private static Dictionary<string, HashSet<string>> BuildDependencyGraph(\n        ImmutableArray<TestMethodDescriptor> tests)\n    {\n        var graph = new Dictionary<string, HashSet<string>>();\n        foreach (var test in tests)\n        {\n            graph[test.Id] = new HashSet<string>(test.Dependencies);\n        }\n        return graph;\n    }\n```","created_at":"2026-01-24T08:25:12Z","updated_at":"2026-01-24T08:25:12Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871966","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871966"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723871966"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723871966/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":32,"start_side":"RIGHT","line":null,"original_line":41,"side":"RIGHT","author_association":"NONE","original_position":41,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872101","pull_request_review_id":3701058741,"id":2723872101,"node_id":"PRRC_kwDOQhEeKs6iWv1l","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Missed opportunity to use Where\n\nThis foreach loop <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/9755f351c684679fbcbb73f192a330bd74db1ec6/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L66-L66\">implicitly filters its target sequence</a> - consider filtering the sequence explicitly using '.Where(...)'.\n\n---\n\nIn general, to fix this type of issue you replace a <code>foreach</code> loop that conditionally processes elements (e.g., via an <code>if</code> inside the loop) with a LINQ query that filters the sequence using <code>Where</code>, and then iterate over the filtered sequence or apply <code>foreach</code> to it. This makes the filtering explicit and improves clarity.</p>\n<p>For this specific case in <code>ValidateDependencies</code> in <code>src/NextUnit.Generator/Validators/TestMethodValidator.cs</code>, you should change the loop:</p>\n<pre><code>foreach (var depId in test.Dependencies)\n{\n    if (!dependencyGraph.ContainsKey(depId))\n    {\n        // report diagnostic\n    }\n}\n</code></pre>\n<p>to a loop over a filtered sequence:</p>\n<pre><code>foreach (var depId in test.Dependencies.Where(depId =&gt; !dependencyGraph.ContainsKey(depId)))\n{\n    // report diagnostic\n}\n</code></pre>\n<p>This keeps the diagnostic behavior exactly the same: for each dependency ID that is not present in <code>dependencyGraph</code>, report the diagnostic. To support the <code>.Where</code> call, add <code>using System.Linq;</code> at the top of the file (it is a wellknown BCL namespace). No other methods or definitions are needed. The change is local to <code>TestMethodValidator.ValidateDependencies</code> and does not modify any diagnostics or public behavior.","created_at":"2026-01-24T08:25:30Z","updated_at":"2026-01-24T08:25:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872101","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872101"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872101"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872101/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":64,"start_side":"RIGHT","line":null,"original_line":80,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":80,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872102","pull_request_review_id":3701058741,"id":2723872102,"node_id":"PRRC_kwDOQhEeKs6iWv1m","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Missed opportunity to use Where\n\nThis foreach loop <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/9755f351c684679fbcbb73f192a330bd74db1ec6/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L160-L160\">implicitly filters its target sequence</a> - consider filtering the sequence explicitly using '.Where(...)'.\n\n---\n\nIn general, to address this kind of issue, move the filtering condition from inside the <code>foreach</code> body into a LINQ <code>.Where(...)</code> clause on the sequence you are iterating. This makes it explicit that only elements matching (or not matching) a predicate are of interest, and keeps the loop body focused on the action to take for those elements.</p>\n<p>In this specific case, we should iterate only over those <code>MatrixExclusions</code> where <code>exclusion.Values.Length != test.MatrixParameters.Length</code>. We can do this by changing the <code>foreach (var exclusion in test.MatrixExclusions)</code> to <code>foreach (var exclusion in test.MatrixExclusions.Where(...))</code>, and removing the inner <code>if</code> statement. This keeps behavior identical: diagnostics are produced for each exclusion whose <code>Values</code> length does not match the number of matrix parameters, and nothing is done for matching ones. To compile, we need LINQ extension methods; if <code>System.Linq</code> is not already imported elsewhere in this file, we must add <code>using System.Linq;</code> at the top. All changes are confined to <code>ValidateMatrixParameters</code> in <code>src/NextUnit.Generator/Validators/TestMethodValidator.cs</code>.","created_at":"2026-01-24T08:25:30Z","updated_at":"2026-01-24T08:25:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872102","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872102"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872102"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872102/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":158,"start_side":"RIGHT","line":null,"original_line":175,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":175,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872103","pull_request_review_id":3701058741,"id":2723872103,"node_id":"PRRC_kwDOQhEeKs6iWv1n","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Missed opportunity to use Where\n\nThis foreach loop <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/9755f351c684679fbcbb73f192a330bd74db1ec6/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L204-L204\">implicitly filters its target sequence</a> - consider filtering the sequence explicitly using '.Where(...)'.\n\n---\n\nIn general, to fix this kind of issue, you move the conditional that filters items inside a <code>foreach</code> loop into an explicit LINQ <code>.Where(...)</code> call on the sequence you are iterating. This makes it clear that only a subset of the sequence is relevant, and avoids an empty loop body for most elements.</p>\n<p>For this specific case in <code>ValidateClassDataSources</code> (file <code>src/NextUnit.Generator/Validators/TestMethodValidator.cs</code>), we should change:</p>\n<pre><code>foreach (var source in test.ClassDataSources)\n{\n    if (source.SharedType == SharedTypeConstants.Keyed &amp;&amp; string.IsNullOrEmpty(source.Key))\n    {\n        // report diagnostic\n    }\n}\n</code></pre>\n<p>to:</p>\n<pre><code>foreach (var source in test.ClassDataSources\n    .Where(s =&gt; s.SharedType == SharedTypeConstants.Keyed &amp;&amp; string.IsNullOrEmpty(s.Key)))\n{\n    // report diagnostic\n}\n</code></pre>\n<p>This preserves functionality: diagnostics are still reported only for <code>ClassDataSources</code> entries with <code>SharedTypeConstants.Keyed</code> and an empty or null <code>Key</code>. To compile, we need <code>using System.Linq;</code> at the top of the file, since <code>.Where</code> is an extension method. No other behavior or signatures change.","created_at":"2026-01-24T08:25:30Z","updated_at":"2026-01-24T08:25:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872103","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872103"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872103"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872103/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":202,"start_side":"RIGHT","line":null,"original_line":217,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":217,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872105","pull_request_review_id":3701058741,"id":2723872105,"node_id":"PRRC_kwDOQhEeKs6iWv1p","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Missed opportunity to use Where\n\nThis foreach loop <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/9755f351c684679fbcbb73f192a330bd74db1ec6/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L270-L272\">implicitly filters its target sequence</a> - consider filtering the sequence explicitly using '.Where(...)'.\n\n---\n\nGenerally, to address this CodeQL warning, you move the filtering condition from inside the <code>foreach</code> body into a LINQ <code>Where</code> call applied to the sequence you are iterating. This makes the intention iterate only over elements that satisfy this predicate explicit and removes the implicit filtering via an internal <code>if</code>.</p>\n<p>For this specific code in <code>ValidateCombinedParameterSources</code>, the best fix is:</p>\n<ul>\n<li>Add a <code>using System.Linq;</code> at the top of the file so that <code>Where</code> is available as an extension method.</li>\n<li>Replace the <code>foreach (var source in test.CombinedParameterSources)</code> plus the inner <code>if (source.Kind == ... &amp;&amp; ...) { ... }</code> with a <code>foreach</code> over <code>test.CombinedParameterSources.Where(...)</code>, and then drop the inner <code>if</code>, keeping only the diagnostic reporting inside the loop. This preserves behavior: diagnostics are reported for exactly the same sources, only the filtering is made explicit in the enumeration.</li>\n</ul>\n<p>Concretely:</p>\n<ul>\n<li>In <code>src/NextUnit.Generator/Validators/TestMethodValidator.cs</code>, add <code>using System.Linq;</code> below the existing <code>using</code> directives.</li>\n<li>In the same file, lines 268286, replace the existing <code>foreach</code> block with a new <code>foreach</code> that iterates over <code>test.CombinedParameterSources.Where(source =&gt; &lt;same condition&gt;)</code> and directly reports the diagnostic inside the loop.</li>\n</ul>\n<p>No new methods or other definitions are needed beyond the <code>System.Linq</code> import.","created_at":"2026-01-24T08:25:30Z","updated_at":"2026-01-24T08:25:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872105","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872105"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872105"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872105/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":268,"start_side":"RIGHT","line":null,"original_line":286,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":286,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872107","pull_request_review_id":3701058741,"id":2723872107,"node_id":"PRRC_kwDOQhEeKs6iWv1r","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }\n+    }\n+\n+    private static bool HasCycle(\n+        string testId,\n+        System.Collections.Generic.HashSet<string> visited,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> graph)\n+    {\n+        if (!visited.Add(testId))\n+        {\n+            return true;\n+        }\n+\n+        if (!graph.TryGetValue(testId, out var dependencies))\n+        {\n+            visited.Remove(testId);\n+            return false;\n+        }\n+\n+        foreach (var dep in dependencies)\n+        {\n+            if (HasCycle(dep, visited, graph))\n+            {\n+                return true;\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Missed opportunity to use Where\n\n<p>This foreach loop <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/9755f351c684679fbcbb73f192a330bd74db1ec6/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L307-L307\">implicitly filters its target sequence</a> - consider filtering the sequence explicitly using '.Where(...)'.</p>","created_at":"2026-01-24T08:25:30Z","updated_at":"2026-01-24T08:25:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872107","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872107"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723872107"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723872107/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":305,"start_side":"RIGHT","line":null,"original_line":311,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":311,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881234","pull_request_review_id":3701067044,"id":2723881234,"node_id":"PRRC_kwDOQhEeKs6iWyES","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"Avoid using fully qualified type names. Add `using System.Collections.Generic;` at the top of the file and use `Dictionary<string, HashSet<string>>` for better readability.","created_at":"2026-01-24T08:38:30Z","updated_at":"2026-01-24T08:38:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881234","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881234"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881234"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881234/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":32,"start_side":"RIGHT","line":null,"original_line":35,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":35,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881235","pull_request_review_id":3701067044,"id":2723881235,"node_id":"PRRC_kwDOQhEeKs6iWyET","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"The loop iterates through all sources even though the condition filters most of them. Consider using LINQ's `Where` clause to pre-filter, making the intent clearer and potentially more efficient: `foreach (var source in test.CombinedParameterSources.Where(s => s.Kind == ParameterDataSourceKind.Class && s.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(s.SharedKey)))`.","created_at":"2026-01-24T08:38:31Z","updated_at":"2026-01-24T08:38:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881235","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881235"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881235"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881235/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":268,"start_side":"RIGHT","line":null,"original_line":273,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":273,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881238","pull_request_review_id":3701067044,"id":2723881238,"node_id":"PRRC_kwDOQhEeKs6iWyEW","diff_hunk":"@@ -0,0 +1,168 @@\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Diagnostics;\n+using System.Reflection;\n+\n+namespace NextUnit.Internal;\n+\n+/// <summary>\n+/// Provides unified display name building functionality for test cases.\n+/// Consolidates duplicate logic from ClassDataSourceExpander, CombinedDataSourceExpander, and TestDataExpander.\n+/// </summary>\n+internal static class DisplayNameBuilder\n+{\n+    private static readonly ConcurrentDictionary<Type, IDisplayNameFormatter> _formatterCache = new();\n+\n+    /// <summary>\n+    /// Builds a display name for a test case using the priority order:\n+    /// 1. Custom formatter (if formatterType is specified)\n+    /// 2. Custom template with placeholders (if customDisplayNameTemplate is specified)\n+    /// 3. Default formatting (MethodName(arg1, arg2, ...))\n+    /// </summary>\n+    /// <param name=\"methodName\">The test method name.</param>\n+    /// <param name=\"customDisplayNameTemplate\">Optional custom display name template with placeholders.</param>\n+    /// <param name=\"formatterType\">Optional custom formatter type implementing IDisplayNameFormatter.</param>\n+    /// <param name=\"testClass\">The test class type.</param>\n+    /// <param name=\"arguments\">The test arguments.</param>\n+    /// <param name=\"argumentSetIndex\">The index of the argument set (for default naming).</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string Build(\n+        string methodName,\n+        string? customDisplayNameTemplate,\n+        Type? formatterType,\n+        Type testClass,\n+        object?[] arguments,\n+        int argumentSetIndex)\n+    {\n+        // Priority 1: Custom formatter\n+        if (formatterType is not null)\n+        {\n+            try\n+            {\n+                var formatter = GetFormatter(formatterType);\n+                var context = new DisplayNameContext\n+                {\n+                    MethodName = methodName,\n+                    TestClass = testClass,\n+                    Arguments = arguments,\n+                    ArgumentSetIndex = argumentSetIndex\n+                };\n+                return formatter.Format(context);\n+            }\n+            catch (InvalidOperationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.Message}\");\n+                // Fall through to next priority\n+            }\n+            catch (TargetInvocationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.InnerException?.Message ?? ex.Message}\");\n+                // Fall through to next priority\n+            }\n+        }\n+\n+        // Priority 2: Custom template with placeholders\n+        if (customDisplayNameTemplate is not null)\n+        {\n+            return FormatWithPlaceholders(customDisplayNameTemplate, arguments);\n+        }\n+\n+        // Priority 3: Default formatting\n+        if (arguments.Length == 0)\n+        {\n+            return methodName;\n+        }\n+\n+        var formattedArgs = string.Join(\", \", arguments.Select(FormatArgument));\n+        return $\"{methodName}({formattedArgs})\";\n+    }\n+\n+    /// <summary>\n+    /// Formats a display name template by replacing placeholders with argument values.\n+    /// Supports {0}, {1}, etc. for positional arguments.\n+    /// </summary>\n+    /// <param name=\"template\">The template string with placeholders.</param>\n+    /// <param name=\"arguments\">The arguments to substitute.</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string FormatWithPlaceholders(string template, object?[] arguments)\n+    {\n+        var result = template;\n+\n+        for (var i = 0; i < arguments.Length; i++)\n+        {\n+            var placeholder = $\"{{{i}}}\";\n+            if (result.Contains(placeholder))\n+            {\n+                result = result.Replace(placeholder, FormatArgument(arguments[i]));\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /// <summary>\n+    /// Formats a single argument value for display.\n+    /// Handles null, strings, chars, booleans, enumerables, and general objects.\n+    /// </summary>\n+    /// <param name=\"arg\">The argument to format.</param>\n+    /// <returns>The formatted string representation.</returns>\n+    public static string FormatArgument(object? arg)\n+    {\n+        return arg switch\n+        {\n+            null => \"null\",\n+            string s => $\"\\\"{s}\\\"\",\n+            char c => $\"'{c}'\",\n+            bool b => FormatBoolean(b),\n+            IEnumerable enumerable when arg is not string => FormatEnumerable(enumerable),\n+            _ => arg.ToString() ?? \"null\"\n+        };\n+    }\n+\n+    /// <summary>\n+    /// Formats a boolean value as lowercase \"true\" or \"false\".\n+    /// </summary>\n+    /// <param name=\"value\">The boolean value.</param>\n+    /// <returns>\"true\" or \"false\" in lowercase.</returns>\n+    public static string FormatBoolean(bool value) => value ? \"true\" : \"false\";","path":"src/NextUnit.Core/Internal/DisplayNameBuilder.cs","commit_id":"8509fc2a53d7cf431c88a66bddfcfecd79fcabf5","original_commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","user":{"login":"Copilot","id":175728472,"node_id":"BOT_kgDOCnlnWA","avatar_url":"https://avatars.githubusercontent.com/in/946600?v=4","gravatar_id":"","url":"https://api.github.com/users/Copilot","html_url":"https://github.com/apps/copilot-pull-request-reviewer","followers_url":"https://api.github.com/users/Copilot/followers","following_url":"https://api.github.com/users/Copilot/following{/other_user}","gists_url":"https://api.github.com/users/Copilot/gists{/gist_id}","starred_url":"https://api.github.com/users/Copilot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Copilot/subscriptions","organizations_url":"https://api.github.com/users/Copilot/orgs","repos_url":"https://api.github.com/users/Copilot/repos","events_url":"https://api.github.com/users/Copilot/events{/privacy}","received_events_url":"https://api.github.com/users/Copilot/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"This method creates a new string on each call. Consider using `bool.TrueString.ToLowerInvariant()` and `bool.FalseString.ToLowerInvariant()` with caching, or use `value.ToString().ToLowerInvariant()` which matches the original implementation pattern.","created_at":"2026-01-24T08:38:31Z","updated_at":"2026-01-24T08:38:31Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881238","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881238"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723881238"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723881238/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":126,"original_line":127,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":127,"position":126,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723883408","pull_request_review_id":3701068469,"id":2723883408,"node_id":"PRRC_kwDOQhEeKs6iWymQ","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Now using short type names (Dictionary, HashSet) via implicit usings.","created_at":"2026-01-24T08:43:25Z","updated_at":"2026-01-24T08:43:25Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723883408","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723883408"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723883408"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723883408/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":32,"start_side":"RIGHT","line":null,"original_line":41,"side":"RIGHT","in_reply_to_id":2723870638,"author_association":"MEMBER","original_position":41,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884117","pull_request_review_id":3701069257,"id":2723884117,"node_id":"PRRC_kwDOQhEeKs6iWyxV","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af - using short type names via implicit usings.","created_at":"2026-01-24T08:44:09Z","updated_at":"2026-01-24T08:44:09Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884117","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884117"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884117"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884117/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":46,"side":"RIGHT","in_reply_to_id":2723870641,"author_association":"MEMBER","original_position":46,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884158","pull_request_review_id":3701069276,"id":2723884158,"node_id":"PRRC_kwDOQhEeKs6iWyx-","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af - using short type names via implicit usings.","created_at":"2026-01-24T08:44:10Z","updated_at":"2026-01-24T08:44:10Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884158","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884158"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884158"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884158/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":49,"side":"RIGHT","in_reply_to_id":2723870642,"author_association":"MEMBER","original_position":49,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884167","pull_request_review_id":3701069286,"id":2723884167,"node_id":"PRRC_kwDOQhEeKs6iWyyH","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }\n+    }\n+\n+    private static bool HasCycle(\n+        string testId,\n+        System.Collections.Generic.HashSet<string> visited,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> graph)","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af - using short type names via implicit usings.","created_at":"2026-01-24T08:44:11Z","updated_at":"2026-01-24T08:44:11Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884167","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884167"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884167"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884167/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":291,"start_side":"RIGHT","line":null,"original_line":292,"side":"RIGHT","in_reply_to_id":2723870644,"author_association":"MEMBER","original_position":292,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884542","pull_request_review_id":3701069655,"id":2723884542,"node_id":"PRRC_kwDOQhEeKs6iWy3-","diff_hunk":"@@ -0,0 +1,168 @@\n+using System.Collections;\n+using System.Collections.Concurrent;\n+using System.Diagnostics;\n+using System.Reflection;\n+\n+namespace NextUnit.Internal;\n+\n+/// <summary>\n+/// Provides unified display name building functionality for test cases.\n+/// Consolidates duplicate logic from ClassDataSourceExpander, CombinedDataSourceExpander, and TestDataExpander.\n+/// </summary>\n+internal static class DisplayNameBuilder\n+{\n+    private static readonly ConcurrentDictionary<Type, IDisplayNameFormatter> FormatterCache = new();\n+\n+    /// <summary>\n+    /// Builds a display name for a test case using the priority order:\n+    /// 1. Custom formatter (if formatterType is specified)\n+    /// 2. Custom template with placeholders (if customDisplayNameTemplate is specified)\n+    /// 3. Default formatting (MethodName(arg1, arg2, ...))\n+    /// </summary>\n+    /// <param name=\"methodName\">The test method name.</param>\n+    /// <param name=\"customDisplayNameTemplate\">Optional custom display name template with placeholders.</param>\n+    /// <param name=\"formatterType\">Optional custom formatter type implementing IDisplayNameFormatter.</param>\n+    /// <param name=\"testClass\">The test class type.</param>\n+    /// <param name=\"arguments\">The test arguments.</param>\n+    /// <param name=\"argumentSetIndex\">The index of the argument set (for default naming).</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string Build(\n+        string methodName,\n+        string? customDisplayNameTemplate,\n+        Type? formatterType,\n+        Type testClass,\n+        object?[] arguments,\n+        int argumentSetIndex)\n+    {\n+        // Priority 1: Custom formatter\n+        if (formatterType is not null)\n+        {\n+            try\n+            {\n+                var formatter = GetFormatter(formatterType);\n+                var context = new DisplayNameContext\n+                {\n+                    MethodName = methodName,\n+                    TestClass = testClass,\n+                    Arguments = arguments,\n+                    ArgumentSetIndex = argumentSetIndex\n+                };\n+                return formatter.Format(context);\n+            }\n+            catch (InvalidOperationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.Message}\");\n+                // Fall through to next priority\n+            }\n+            catch (TargetInvocationException ex)\n+            {\n+                Debug.WriteLine($\"[NextUnit] DisplayNameFormatter '{formatterType.FullName}' failed: {ex.InnerException?.Message ?? ex.Message}\");\n+                // Fall through to next priority\n+            }\n+        }\n+\n+        // Priority 2: Custom template with placeholders\n+        if (customDisplayNameTemplate is not null)\n+        {\n+            return FormatWithPlaceholders(customDisplayNameTemplate, arguments);\n+        }\n+\n+        // Priority 3: Default formatting\n+        if (arguments.Length == 0)\n+        {\n+            return methodName;\n+        }\n+\n+        var formattedArgs = string.Join(\", \", arguments.Select(FormatArgument));\n+        return $\"{methodName}({formattedArgs})\";\n+    }\n+\n+    /// <summary>\n+    /// Formats a display name template by replacing placeholders with argument values.\n+    /// Supports {0}, {1}, etc. for positional arguments.\n+    /// </summary>\n+    /// <param name=\"template\">The template string with placeholders.</param>\n+    /// <param name=\"arguments\">The arguments to substitute.</param>\n+    /// <returns>The formatted display name.</returns>\n+    public static string FormatWithPlaceholders(string template, object?[] arguments)\n+    {\n+        var result = template;\n+\n+        for (var i = 0; i < arguments.Length; i++)\n+        {\n+            var placeholder = $\"{{{i}}}\";\n+            if (result.Contains(placeholder))\n+            {\n+                result = result.Replace(placeholder, FormatArgument(arguments[i]));\n+            }\n+        }\n+\n+        return result;","path":"src/NextUnit.Core/Internal/DisplayNameBuilder.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Now using StringBuilder for efficient in-place replacements.","created_at":"2026-01-24T08:44:24Z","updated_at":"2026-01-24T08:44:24Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884542","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884542"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884542"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884542/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":89,"start_side":"RIGHT","line":null,"original_line":100,"side":"RIGHT","in_reply_to_id":2723871962,"author_association":"MEMBER","original_position":100,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884779","pull_request_review_id":3701069902,"id":2723884779,"node_id":"PRRC_kwDOQhEeKs6iWy7r","diff_hunk":"@@ -51,4 +53,65 @@ public static void Dispose(object? instance)\n             asyncDisposable.DisposeAsync().AsTask().ConfigureAwait(false).GetAwaiter().GetResult();\n         }\n     }\n+\n+    /// <summary>\n+    /// Disposes all objects in a collection.\n+    /// </summary>\n+    /// <param name=\"instances\">The collection of objects to dispose.</param>\n+    public static void DisposeAllIn(IEnumerable<object> instances)\n+    {\n+        foreach (var instance in instances)\n+        {\n+            DisposeIfNeeded(instance);\n+        }\n+    }\n+\n+    /// <summary>\n+    /// Disposes an object with error handling for cleanup scenarios.\n+    /// Logs errors but does not throw (except for fatal exceptions).\n+    /// </summary>\n+    /// <param name=\"instance\">The object to dispose.</param>\n+    /// <remarks>\n+    /// <para>\n+    /// <b>Warning:</b> This method blocks on async disposal using GetAwaiter().GetResult().\n+    /// In synchronization contexts that don't allow blocking (e.g., UI threads),\n+    /// this could potentially cause deadlocks. In test frameworks, this is typically safe\n+    /// as tests run on thread pool threads without special synchronization contexts.\n+    /// </para>\n+    /// <para>\n+    /// If deadlocks occur in production use, consider implementing a fully async cleanup path.\n+    /// </para>\n+    /// </remarks>\n+    public static void DisposeIfNeeded(object? instance)\n+    {\n+        if (instance is null)\n+        {\n+            return;\n+        }\n+\n+        try\n+        {\n+            if (instance is IAsyncDisposable asyncDisposable)\n+            {\n+                asyncDisposable.DisposeAsync().AsTask().GetAwaiter().GetResult();\n+            }\n+            else if (instance is IDisposable disposable)\n+            {\n+                disposable.Dispose();\n+            }","path":"src/NextUnit.Core/Internal/DisposeHelper.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. DisposeIfNeeded now prefers IDisposable over IAsyncDisposable, consistent with other disposal methods in this class.","created_at":"2026-01-24T08:44:33Z","updated_at":"2026-01-24T08:44:34Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884779","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884779"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723884779"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723884779/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":94,"start_side":"RIGHT","line":null,"original_line":101,"side":"RIGHT","in_reply_to_id":2723871964,"author_association":"MEMBER","original_position":55,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885007","pull_request_review_id":3701070145,"id":2723885007,"node_id":"PRRC_kwDOQhEeKs6iWy_P","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:49Z","updated_at":"2026-01-24T08:44:49Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885007","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885007"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885007"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885007/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":32,"start_side":"RIGHT","line":null,"original_line":41,"side":"RIGHT","in_reply_to_id":2723871966,"author_association":"MEMBER","original_position":41,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885052","pull_request_review_id":3701070269,"id":2723885052,"node_id":"PRRC_kwDOQhEeKs6iWy_8","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:50Z","updated_at":"2026-01-24T08:44:50Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885052","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885052"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885052"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885052/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":64,"start_side":"RIGHT","line":null,"original_line":80,"side":"RIGHT","in_reply_to_id":2723872101,"author_association":"MEMBER","original_position":80,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885079","pull_request_review_id":3701070289,"id":2723885079,"node_id":"PRRC_kwDOQhEeKs6iWzAX","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:51Z","updated_at":"2026-01-24T08:44:51Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885079","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885079"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885079"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885079/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":158,"start_side":"RIGHT","line":null,"original_line":175,"side":"RIGHT","in_reply_to_id":2723872102,"author_association":"MEMBER","original_position":175,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885125","pull_request_review_id":3701070336,"id":2723885125,"node_id":"PRRC_kwDOQhEeKs6iWzBF","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:52Z","updated_at":"2026-01-24T08:44:52Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885125","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885125"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885125"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885125/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":202,"start_side":"RIGHT","line":null,"original_line":217,"side":"RIGHT","in_reply_to_id":2723872103,"author_association":"MEMBER","original_position":217,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885169","pull_request_review_id":3701070373,"id":2723885169,"node_id":"PRRC_kwDOQhEeKs6iWzBx","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:53Z","updated_at":"2026-01-24T08:44:53Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885169","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885169"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885169"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885169/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":268,"start_side":"RIGHT","line":null,"original_line":286,"side":"RIGHT","in_reply_to_id":2723872105,"author_association":"MEMBER","original_position":286,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885303","pull_request_review_id":3701070481,"id":2723885303,"node_id":"PRRC_kwDOQhEeKs6iWzD3","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }\n+    }\n+\n+    private static bool HasCycle(\n+        string testId,\n+        System.Collections.Generic.HashSet<string> visited,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> graph)\n+    {\n+        if (!visited.Add(testId))\n+        {\n+            return true;\n+        }\n+\n+        if (!graph.TryGetValue(testId, out var dependencies))\n+        {\n+            visited.Remove(testId);\n+            return false;\n+        }\n+\n+        foreach (var dep in dependencies)\n+        {\n+            if (HasCycle(dep, visited, graph))\n+            {\n+                return true;\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 07359af. Using LINQ Where() for explicit filtering and short type names.","created_at":"2026-01-24T08:44:58Z","updated_at":"2026-01-24T08:44:58Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885303","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885303"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885303"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885303/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":305,"start_side":"RIGHT","line":null,"original_line":311,"side":"RIGHT","in_reply_to_id":2723872107,"author_association":"MEMBER","original_position":311,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885650","pull_request_review_id":3701070860,"id":2723885650,"node_id":"PRRC_kwDOQhEeKs6iWzJS","diff_hunk":"@@ -0,0 +1,316 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new System.Collections.Generic.HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new System.Collections.Generic.HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies)\n+        {\n+            if (!dependencyGraph.ContainsKey(depId))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT002\",\n+                        \"Unresolved test dependency\",\n+                        \"Test '{0}' depends on '{1}' which does not exist\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Warning,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    depId));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions)\n+            {\n+                if (exclusion.Values.Length != test.MatrixParameters.Length)\n+                {\n+                    context.ReportDiagnostic(Diagnostic.Create(\n+                        new DiagnosticDescriptor(\n+                            \"NEXTUNIT007\",\n+                            \"Matrix exclusion parameter count mismatch\",\n+                            \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                            \"NextUnit\",\n+                            DiagnosticSeverity.Error,\n+                            isEnabledByDefault: true),\n+                        Location.None,\n+                        test.Id,\n+                        exclusion.Values.Length,\n+                        test.MatrixParameters.Length));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources)\n+        {\n+            if (source.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(source.Key))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT009\",\n+                        \"Missing Key for Keyed ClassDataSource\",\n+                        \"Test '{0}' uses ClassDataSource with SharedType.Keyed but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateCombinedParameterSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.CombinedParameterSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty ||\n+            !test.MatrixParameters.IsDefaultOrEmpty || !test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT010\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' uses parameter-level data sources ([Values], [ValuesFromMember], [ValuesFrom]) with other data source attributes. Only parameter-level sources will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // All parameters must have a data source (except trailing CancellationToken)\n+        var expectedSourceCount = test.Parameters.Length;\n+        if (test.Parameters.Length > 0 &&\n+            test.Parameters[test.Parameters.Length - 1].Type.ToDisplayString() == \"System.Threading.CancellationToken\")\n+        {\n+            expectedSourceCount = test.Parameters.Length - 1;\n+        }\n+\n+        if (test.CombinedParameterSources.Length != expectedSourceCount)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT011\",\n+                    \"Incomplete parameter data sources\",\n+                    \"Test '{0}' has {1} parameters but only {2} have data source attributes ([Values], [ValuesFromMember], or [ValuesFrom]). All parameters must have a data source when using combined data sources (CancellationToken excluded).\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                expectedSourceCount,\n+                test.CombinedParameterSources.Length));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.CombinedParameterSources)\n+        {\n+            if (source.Kind == ParameterDataSourceKind.Class &&\n+                source.SharedType == SharedTypeConstants.Keyed &&\n+                string.IsNullOrEmpty(source.SharedKey))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT012\",\n+                        \"Missing Key for Keyed ValuesFrom\",\n+                        \"Test '{0}' uses [ValuesFrom] with SharedType.Keyed on parameter '{1}' but no Key is specified.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    source.ParameterName));\n+            }\n+        }\n+    }\n+\n+    private static bool HasCycle(\n+        string testId,\n+        System.Collections.Generic.HashSet<string> visited,\n+        System.Collections.Generic.Dictionary<string, System.Collections.Generic.HashSet<string>> graph)\n+    {\n+        if (!visited.Add(testId))\n+        {\n+            return true;\n+        }\n+\n+        if (!graph.TryGetValue(testId, out var dependencies))\n+        {\n+            visited.Remove(testId);\n+            return false;\n+        }\n+\n+        foreach (var dep in dependencies)\n+        {\n+            if (HasCycle(dep, visited, graph))\n+            {\n+                return true;\n+            }\n+        }","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"5141de2e6e63007713010243b2bcf74516aa9328","original_commit_id":"9755f351c684679fbcbb73f192a330bd74db1ec6","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"The ternary approach (value ? \"true\" : \"false\") is actually more efficient than ToString().ToLowerInvariant() as it avoids string allocation and culture-related operations. The string literals are interned, so no allocation occurs. This is a deliberate optimization.","created_at":"2026-01-24T08:45:11Z","updated_at":"2026-01-24T08:45:11Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885650","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885650"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723885650"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723885650/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":305,"start_side":"RIGHT","line":null,"original_line":311,"side":"RIGHT","in_reply_to_id":2723872107,"author_association":"MEMBER","original_position":311,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723886105","pull_request_review_id":3701071371,"id":2723886105,"node_id":"PRRC_kwDOQhEeKs6iWzQZ","diff_hunk":"@@ -0,0 +1,302 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static Dictionary<string, HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new Dictionary<string, HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        Dictionary<string, HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies.Where(depId => !dependencyGraph.ContainsKey(depId)))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT002\",\n+                    \"Unresolved test dependency\",\n+                    \"Test '{0}' depends on '{1}' which does not exist\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                depId));\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions.Where(e => e.Values.Length != test.MatrixParameters.Length))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT007\",\n+                        \"Matrix exclusion parameter count mismatch\",\n+                        \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    exclusion.Values.Length,\n+                    test.MatrixParameters.Length));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources.Where(s => s.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(s.Key)))","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"07359af9edbb8e27bc2b3ab622c0fc5fd574a803","original_commit_id":"07359af9edbb8e27bc2b3ab622c0fc5fd574a803","user":{"login":"github-code-quality[bot]","id":223894421,"node_id":"BOT_kgDODVhblQ","avatar_url":"https://avatars.githubusercontent.com/u/9919?v=4","gravatar_id":"","url":"https://api.github.com/users/github-code-quality%5Bbot%5D","html_url":"https://github.com/apps/github-code-quality","followers_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/followers","following_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/repos","events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/github-code-quality%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"## Useless assignment to local variable\n\nThis assignment to <a class=\"Link\" href=\"/crane-valley/NextUnit/blob/07359af9edbb8e27bc2b3ab622c0fc5fd574a803/src/NextUnit.Generator/Validators/TestMethodValidator.cs#L196-L196\">source</a> is useless, since its value is never read.\n\n---\n\n<p>In general, to fix a useless assignment to local variable in a <code>foreach</code> loop where the loop variable is never used, you either remove the loop (if the iterations have no effect) or acknowledge that you only care about the number of elements by discarding the loop variable. In C#, this is commonly expressed by using <code>_</code> as the loop variable name, which makes the intent explicit and avoids misleading readers into thinking the element is used.</p>\n<p>For this specific case in <code>ValidateClassDataSources</code> in <code>src/NextUnit.Generator/Validators/TestMethodValidator.cs</code>, the loop is needed because we want to issue one diagnostic per offending class data source, but we do not use any property of the individual <code>source</code>. The best minimal fix is to change the loop variable name from <code>source</code> to <code>_</code>. This keeps the behavior identical (still one diagnostic per matching element) while removing the useless variable and satisfying the analyzer. No new methods, imports, or other definitions are required; only the <code>foreach</code> declaration line needs to be edited.</p>\n<p>Concretely, on line 196, change:</p>\n<pre><code>foreach (var source in test.ClassDataSources.Where(s =&gt; s.SharedType == SharedTypeConstants.Keyed &amp;&amp; string.IsNullOrEmpty(s.Key)))\n</code></pre>\n<p>to:</p>\n<pre><code>foreach (var _ in test.ClassDataSources.Where(s =&gt; s.SharedType == SharedTypeConstants.Keyed &amp;&amp; string.IsNullOrEmpty(s.Key)))\n</code></pre>","created_at":"2026-01-24T08:45:33Z","updated_at":"2026-01-24T08:45:33Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723886105","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723886105"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723886105"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723886105/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":196,"side":"RIGHT","author_association":"CONTRIBUTOR","original_position":196,"position":1,"subject_type":"line"},{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723888218","pull_request_review_id":3701074069,"id":2723888218,"node_id":"PRRC_kwDOQhEeKs6iWzxa","diff_hunk":"@@ -0,0 +1,302 @@\n+using System.Collections.Immutable;\n+using Microsoft.CodeAnalysis;\n+using NextUnit.Generator.Helpers;\n+using NextUnit.Generator.Models;\n+\n+namespace NextUnit.Generator.Validators;\n+\n+/// <summary>\n+/// Validates test method descriptors and reports diagnostics for common issues.\n+/// </summary>\n+internal static class TestMethodValidator\n+{\n+    /// <summary>\n+    /// Validates all test methods and reports diagnostics.\n+    /// </summary>\n+    public static void ValidateAll(\n+        SourceProductionContext context,\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var dependencyGraph = BuildDependencyGraph(tests);\n+\n+        foreach (var test in tests)\n+        {\n+            ValidateDependencies(context, test, dependencyGraph);\n+            ValidateDataSourceConflicts(context, test);\n+            ValidateMatrixParameters(context, test);\n+            ValidateClassDataSources(context, test);\n+            ValidateCombinedParameterSources(context, test);\n+        }\n+    }\n+\n+    private static Dictionary<string, HashSet<string>> BuildDependencyGraph(\n+        ImmutableArray<TestMethodDescriptor> tests)\n+    {\n+        var graph = new Dictionary<string, HashSet<string>>();\n+        foreach (var test in tests)\n+        {\n+            graph[test.Id] = new HashSet<string>(test.Dependencies);\n+        }\n+        return graph;\n+    }\n+\n+    private static void ValidateDependencies(\n+        SourceProductionContext context,\n+        TestMethodDescriptor test,\n+        Dictionary<string, HashSet<string>> dependencyGraph)\n+    {\n+        // Check for dependency cycles\n+        if (HasCycle(test.Id, new HashSet<string>(), dependencyGraph))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT001\",\n+                    \"Dependency cycle detected\",\n+                    \"Test '{0}' has a circular dependency\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Check for unresolved dependencies\n+        foreach (var depId in test.Dependencies.Where(depId => !dependencyGraph.ContainsKey(depId)))\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT002\",\n+                    \"Unresolved test dependency\",\n+                    \"Test '{0}' depends on '{1}' which does not exist\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                depId));\n+        }\n+    }\n+\n+    private static void ValidateDataSourceConflicts(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        // [Arguments] and [TestData] conflict\n+        if (!test.ArgumentSets.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT003\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Arguments] and [TestData] attributes. [Arguments] will be ignored and only [TestData] will be processed. Remove one of them to avoid confusion.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [Arguments] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.ArgumentSets.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT004\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [Arguments] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // [Matrix] and [TestData] conflict\n+        if (!test.MatrixParameters.IsDefaultOrEmpty && !test.TestDataSources.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT005\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has both [Matrix] and [TestData] attributes. Use only one approach for parameterizing tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+    }\n+\n+    private static void ValidateMatrixParameters(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // All parameters must have [Matrix] if any do\n+        if (test.MatrixParameters.Length != test.Parameters.Length)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT006\",\n+                    \"Incomplete matrix parameters\",\n+                    \"Test '{0}' has {1} parameters but only {2} have [Matrix] attributes. All parameters must have [Matrix] when using matrix tests.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Error,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id,\n+                test.Parameters.Length,\n+                test.MatrixParameters.Length));\n+        }\n+\n+        // [MatrixExclusion] parameter count validation\n+        if (!test.MatrixExclusions.IsDefaultOrEmpty)\n+        {\n+            foreach (var exclusion in test.MatrixExclusions.Where(e => e.Values.Length != test.MatrixParameters.Length))\n+            {\n+                context.ReportDiagnostic(Diagnostic.Create(\n+                    new DiagnosticDescriptor(\n+                        \"NEXTUNIT007\",\n+                        \"Matrix exclusion parameter count mismatch\",\n+                        \"Test '{0}' has [MatrixExclusion] with {1} values but the test has {2} matrix parameters.\",\n+                        \"NextUnit\",\n+                        DiagnosticSeverity.Error,\n+                        isEnabledByDefault: true),\n+                    Location.None,\n+                    test.Id,\n+                    exclusion.Values.Length,\n+                    test.MatrixParameters.Length));\n+            }\n+        }\n+    }\n+\n+    private static void ValidateClassDataSources(SourceProductionContext context, TestMethodDescriptor test)\n+    {\n+        if (test.ClassDataSources.IsDefaultOrEmpty)\n+        {\n+            return;\n+        }\n+\n+        // Conflict with other data source attributes\n+        if (!test.ArgumentSets.IsDefaultOrEmpty || !test.TestDataSources.IsDefaultOrEmpty || !test.MatrixParameters.IsDefaultOrEmpty)\n+        {\n+            context.ReportDiagnostic(Diagnostic.Create(\n+                new DiagnosticDescriptor(\n+                    \"NEXTUNIT008\",\n+                    \"Conflicting test data attributes\",\n+                    \"Test '{0}' has [ClassDataSource] with other data source attributes. Only [ClassDataSource] will be processed.\",\n+                    \"NextUnit\",\n+                    DiagnosticSeverity.Warning,\n+                    isEnabledByDefault: true),\n+                Location.None,\n+                test.Id));\n+        }\n+\n+        // Keyed sharing requires Key\n+        foreach (var source in test.ClassDataSources.Where(s => s.SharedType == SharedTypeConstants.Keyed && string.IsNullOrEmpty(s.Key)))","path":"src/NextUnit.Generator/Validators/TestMethodValidator.cs","commit_id":"07359af9edbb8e27bc2b3ab622c0fc5fd574a803","original_commit_id":"07359af9edbb8e27bc2b3ab622c0fc5fd574a803","user":{"login":"kiyoaki","id":218958,"node_id":"MDQ6VXNlcjIxODk1OA==","avatar_url":"https://avatars.githubusercontent.com/u/218958?v=4","gravatar_id":"","url":"https://api.github.com/users/kiyoaki","html_url":"https://github.com/kiyoaki","followers_url":"https://api.github.com/users/kiyoaki/followers","following_url":"https://api.github.com/users/kiyoaki/following{/other_user}","gists_url":"https://api.github.com/users/kiyoaki/gists{/gist_id}","starred_url":"https://api.github.com/users/kiyoaki/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kiyoaki/subscriptions","organizations_url":"https://api.github.com/users/kiyoaki/orgs","repos_url":"https://api.github.com/users/kiyoaki/repos","events_url":"https://api.github.com/users/kiyoaki/events{/privacy}","received_events_url":"https://api.github.com/users/kiyoaki/received_events","type":"User","user_view_type":"public","site_admin":false},"body":"Fixed in commit 8509fc2. Changed loop variable from 'source' to '_' discard since the value is not used in the loop body.","created_at":"2026-01-24T08:47:30Z","updated_at":"2026-01-24T08:47:30Z","html_url":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723888218","pull_request_url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104","_links":{"self":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723888218"},"html":{"href":"https://github.com/crane-valley/NextUnit/pull/104#discussion_r2723888218"},"pull_request":{"href":"https://api.github.com/repos/crane-valley/NextUnit/pulls/104"}},"reactions":{"url":"https://api.github.com/repos/crane-valley/NextUnit/pulls/comments/2723888218/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":null,"original_start_line":null,"start_side":null,"line":null,"original_line":196,"side":"RIGHT","in_reply_to_id":2723886105,"author_association":"MEMBER","original_position":196,"position":1,"subject_type":"line"}]